<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Krahcore Runner Game - Avoid the Zones</title>
<style>
  body {
    margin: 0; 
    background: #001f2f; 
    color: #00ffff; 
    font-family: 'Courier New', monospace; 
    overflow: hidden;
    display: flex; 
    justify-content: center; 
    align-items: center; 
    height: 100vh;
    flex-direction: column;
  }
  canvas {
    background: #001f2f;
    box-shadow: 0 0 30px #00ffff;
    border-radius: 10px;
  }
  button {
    margin-top: 20px;
    padding: 10px 20px;
    font-family: monospace;
    font-size: 18px;
    background: #00ffff;
    color: #001f2f;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    box-shadow: 0 0 10px #00ffff;
  }
  button:hover {
    background: #00cccc;
  }
  #menu, #gameOverScreen {
    text-align: center;
    max-width: 600px;
  }
  #scoreDisplay {
    position: absolute;
    top: 20px;
    left: 20px;
    font-weight: bold;
    font-size: 24px;
    text-shadow: 0 0 10px #00ffff;
  }
</style>
</head>
<body>

<div id="menu">
  <h1>Krahcore Runner Game</h1>
  <p>Évite la zone rouge qui se déplace sur l'écran. Utilise les flèches gauche/droite pour te déplacer.</p>
  <p>Avant que la zone se déplace, elle pulse pour te prévenir. Plus elle pulse, plus elle va vite !</p>
  <p>Tu gagnes 1 point par seconde.</p>
  <button id="startBtn">Jouer</button>
</div>

<canvas id="game-canvas" width="600" height="400" style="display:none;"></canvas>

<div id="scoreDisplay" style="display:none;">Score: 0</div>

<div id="gameOverScreen" style="display:none;">
  <h2>Game Over !</h2>
  <p id="finalScore"></p>
  <button id="restartBtn">Recommencer</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');
  const menu = document.getElementById('menu');
  const gameOverScreen = document.getElementById('gameOverScreen');
  const finalScoreText = document.getElementById('finalScore');
  const restartBtn = document.getElementById('restartBtn');
  const scoreDisplay = document.getElementById('scoreDisplay');

  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  // Joueur
  const player = {
    x: WIDTH / 2,
    y: HEIGHT - 50,
    radius: 20,
    speed: 6,
    dx: 0,
  };

  // Zone rouge
  const zone = {
    radius: 30,
    x: Math.random() * (WIDTH - 60) + 30,
    y: HEIGHT - 50,
    targetX: 0,
    pulsing: false,
    pulseAlpha: 0,
    pulseDirection: 1,
    moveSpeed: 3,  // pixels/frame, augmente avec temps
    moving: false,
  };

  let keys = {};
  let score = 0;
  let gameOver = false;
  let lastMoveTime = 0;
  let pulseDuration = 500; // ms
  let pulseStartTime = 0;
  let moveStartTime = 0;
  let speedIncreaseInterval = 5000; // toutes les 5s
  let lastSpeedIncrease = 0;

  function resetGame() {
    player.x = WIDTH / 2;
    keys = {};
    score = 0;
    gameOver = false;
    zone.x = Math.random() * (WIDTH - 60) + 30;
    zone.targetX = zone.x;
    zone.pulsing = false;
    zone.pulseAlpha = 0;
    zone.pulseDirection = 1;
    zone.moveSpeed = 3;
    zone.moving = false;
    lastMoveTime = performance.now();
    pulseStartTime = performance.now();
    lastSpeedIncrease = performance.now();
    scoreDisplay.textContent = `Score: 0`;
    scoreDisplay.style.display = 'block';
    gameOverScreen.style.display = 'none';
  }

  function drawPlayer() {
    ctx.fillStyle = '#00ffff';
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawZone() {
    // zone normale
    ctx.fillStyle = '#ff0044';
    ctx.shadowColor = '#ff0044';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
    ctx.fill();

    // pulsation avant déplacement
    if(zone.pulsing) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(zone.targetX, zone.y, zone.radius + 10, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 0, 68, ${zone.pulseAlpha.toFixed(2)})`;
      ctx.shadowColor = `rgba(255, 0, 68, ${zone.pulseAlpha.toFixed(2)})`;
      ctx.shadowBlur = 30;
      ctx.fill();
      ctx.restore();
    }
  }

  function updatePlayer() {
    if(keys['ArrowLeft']) {
      player.dx = -player.speed;
    } else if(keys['ArrowRight']) {
      player.dx = player.speed;
    } else {
      player.dx = 0;
    }

    player.x += player.dx;
    // Clamp dans le canvas
    if(player.x - player.radius < 0) player.x = player.radius;
    if(player.x + player.radius > WIDTH) player.x = WIDTH - player.radius;
  }

  function updateZone(delta) {
    const now = performance.now();

    if(!zone.pulsing && !zone.moving) {
      // Commencer pulsation : choisir nouvelle targetX
      zone.targetX = Math.random() * (WIDTH - 60) + 30;
      zone.pulsing = true;
      pulseStartTime = now;
      zone.pulseAlpha = 0;
      zone.pulseDirection = 1;
    } else if(zone.pulsing) {
      // Pulsation en cours
      let elapsed = now - pulseStartTime;
      // Pulsation alpha va de 0 à 0.7 et retour sur 0.5s
      if(elapsed >= pulseDuration) {
        // fin pulsation, commencer déplacement
        zone.pulsing = false;
        zone.moving = true;
        moveStartTime = now;
      } else {
        // alpha pulsation = sinus pour effet smooth
        const t = elapsed / pulseDuration;
        zone.pulseAlpha = 0.7 * Math.sin(t * Math.PI);
      }
    } else if(zone.moving) {
      // Déplacement vers targetX
      const dir = zone.targetX > zone.x ? 1 : -1;
      zone.x += dir * zone.moveSpeed;

      if((dir === 1 && zone.x >= zone.targetX) || (dir === -1 && zone.x <= zone.targetX)) {
        zone.x = zone.targetX;
        zone.moving = false;
        lastMoveTime = now;
      }
    }

    // Augmentation progressive de la vitesse
    if(now - lastSpeedIncrease > speedIncreaseInterval) {
      zone.moveSpeed += 0.3;
      lastSpeedIncrease = now;
    }
  }

  function checkCollision() {
    // Collision cercle joueur et cercle zone : distance centres < somme rayons
    const dx = player.x - zone.x;
    const dy = player.y - zone.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    return dist < player.radius + zone.radius;
  }

  function drawScore() {
    scoreDisplay.textContent = `Score: ${score}`;
  }

  function gameLoop(timestamp) {
    if(gameOver) return;

    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    updatePlayer();
    updateZone();

    drawPlayer();
    drawZone();

    if(checkCollision()) {
      gameOver = true;
      scoreDisplay.style.display = 'none';
      finalScoreText.textContent = `Ton score : ${score}`;
      gameOverScreen.style.display = 'block';
      return;
    }

    drawScore();

    // Score augmente d'1 point par seconde
    if(!this.lastScoreUpdate) this.lastScoreUpdate = timestamp;
    if(timestamp - this.lastScoreUpdate > 1000) {
      score++;
      this.lastScoreUpdate = timestamp;
      drawScore();
    }

    requestAnimationFrame(gameLoop);
  }

  // Gestion des touches
  window.addEventListener('keydown', e => {
    if(e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
      keys[e.key] = true;
    }
  });
  window.addEventListener('keyup', e => {
    if(e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
      keys[e.key] = false;
    }
  });

  startBtn.addEventListener('click', () => {
    menu.style.display = 'none';
    canvas.style.display = 'block';
    resetGame();
    requestAnimationFrame(gameLoop);
  });

  restartBtn.addEventListener('click', () => {
    gameOverScreen.style.display = 'none';
    resetGame();
    requestAnimationFrame(gameLoop);
  });
})();
</script>

</body>
</html>
