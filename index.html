<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Avoid the Zones - Krahcore Edition</title>
<style>
  body {
    margin: 0; background: #001f2f; color: #00ffff; font-family: 'Courier New', monospace; overflow: hidden;
    display: flex; justify-content: center; align-items: center; height: 100vh;
    flex-direction: column;
  }
  canvas {
    background: #001f2f;
    box-shadow: 0 0 30px #00ffff;
    border-radius: 10px;
  }
  #start-screen {
    text-align: center;
    max-width: 600px;
    margin-bottom: 20px;
  }
  #start-button {
    cursor: pointer;
    background: #00ffff;
    color: #001f2f;
    border: none;
    padding: 12px 25px;
    font-weight: bold;
    border-radius: 6px;
    font-size: 18px;
    box-shadow: 0 0 15px #00ffff;
    transition: background 0.3s;
  }
  #start-button:hover {
    background: #00bbbb;
  }
</style>
</head>
<body>

<div id="start-screen">
  <h1>Krahcore Avoid the Zones</h1>
  <p>Déplace ton cercle bleu avec les touches directionnelles ◀️ ▲ ▼ ▶️ pour éviter la zone rouge.</p>
  <p>La zone rouge se déplace dans toutes les directions après une pulsation qui te donne un indice de sa direction.</p>
  <p>Plus tu tiens longtemps, plus la zone se déplace vite et tu gagnes des points (1 point par seconde).</p>
  <button id="start-button">Jouer</button>
</div>

<canvas id="game-canvas" width="600" height="400" style="display:none;"></canvas>

<script>
(() => {
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  const WIDTH = canvas.width;
  const HEIGHT = canvas.height;

  const startScreen = document.getElementById('start-screen');
  const startButton = document.getElementById('start-button');

  let gameRunning = false;
  let gameOver = false;

  const player = {
    x: WIDTH / 2,
    y: HEIGHT / 2,
    radius: 20,
    speed: 6,
    dx: 0,
    dy: 0
  };

  const zone = {
    x: 100,
    y: HEIGHT - 60,
    radius: 30,
    baseRadius: 30,
    speed: 3,
    direction: {x: 1, y: 0}, // direction unitaire
    pulseTimer: 0,
    pulseDuration: 60, // frames pour pulsation avant déplacement (~1 sec à 60fps)
    moving: false
  };

  let score = 0;
  let highScore = 0;
  let scoreTimer = 0;

  // Sons simplifiés
  let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function playSound(freq, duration=0.1) {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    osc.start();
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.stop(audioCtx.currentTime + duration);
  }

  function resetGame() {
    player.x = WIDTH / 2;
    player.y = HEIGHT / 2;
    player.dx = 0;
    player.dy = 0;

    zone.x = 100;
    zone.y = HEIGHT - 60;
    zone.speed = 3;
    zone.pulseTimer = 0;
    zone.moving = false;
    // Choix aléatoire d'une direction initiale (normalisé)
    const angle = Math.random() * 2 * Math.PI;
    zone.direction.x = Math.cos(angle);
    zone.direction.y = Math.sin(angle);

    score = 0;
    scoreTimer = 0;
    gameOver = false;
  }

  function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }

  function updatePlayer() {
    player.x += player.dx;
    player.y += player.dy;

    // Limites du canvas
    player.x = clamp(player.x, player.radius, WIDTH - player.radius);
    player.y = clamp(player.y, player.radius, HEIGHT - player.radius);
  }

  function updateZone() {
    if(zone.pulseTimer < zone.pulseDuration) {
      zone.pulseTimer++;
    } else {
      zone.moving = true;
    }

    if(zone.moving) {
      zone.x += zone.direction.x * zone.speed;
      zone.y += zone.direction.y * zone.speed;

      // Rebond aux bords du canvas en inversant la direction correspondante
      if(zone.x < zone.radius) {
        zone.x = zone.radius;
        zone.direction.x *= -1;
      }
      if(zone.x > WIDTH - zone.radius) {
        zone.x = WIDTH - zone.radius;
        zone.direction.x *= -1;
      }
      if(zone.y < zone.radius) {
        zone.y = zone.radius;
        zone.direction.y *= -1;
      }
      if(zone.y > HEIGHT - zone.radius) {
        zone.y = HEIGHT - zone.radius;
        zone.direction.y *= -1;
      }
    }

    // Augmentation progressive de la vitesse toutes les 5 secondes (300 frames à 60fps)
    if(zone.moving && scoreTimer % 300 === 0 && scoreTimer !== 0) {
      zone.speed += 0.3;
      playSound(800, 0.07);
    }
  }

  function drawPlayer() {
    ctx.fillStyle = '#00ffff';
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawZone() {
    // Effet pulsation : la zone change de taille pendant la pulsation
    if(zone.pulseTimer < zone.pulseDuration) {
      const pulseProgress = zone.pulseTimer / zone.pulseDuration;
      const scale = 1 + 0.5 * Math.sin(pulseProgress * Math.PI * 4); // 4 oscillations rapides
      ctx.shadowBlur = 20;
      ctx.shadowColor = '#ff0044';
      ctx.fillStyle = `rgba(255, 0, 68, ${0.7 + 0.3 * Math.sin(pulseProgress * Math.PI * 4)})`;
      ctx.beginPath();
      ctx.arc(zone.x, zone.y, zone.radius * scale, 0, Math.PI * 2);
      ctx.fill();
    } else {
      // Zone fixe rouge
      ctx.shadowColor = '#ff0044';
      ctx.shadowBlur = 20;
      ctx.fillStyle = '#ff0044';
      ctx.beginPath();
      ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function checkCollision() {
    const dx = player.x - zone.x;
    const dy = player.y - zone.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist < player.radius + zone.radius) {
      gameOver = true;
      if(score > highScore) highScore = score;
      playSound(150, 0.5);
    }
  }

  function drawScore() {
    ctx.fillStyle = '#00ffff';
    ctx.font = 'bold 24px monospace';
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 10;
    ctx.fillText(`Score: ${score}`, 20, 40);
    ctx.fillText(`High Score: ${highScore}`, 20, 75);
  }

  function drawGameOver() {
    ctx.fillStyle = '#ff0044';
    ctx.font = 'bold 48px monospace';
    ctx.shadowColor = '#ff0044';
    ctx.shadowBlur = 15;
    ctx.fillText('Game Over!', WIDTH/2 - 130, HEIGHT/2);
    ctx.font = '24px monospace';
    ctx.fillText('Appuie sur Entrée pour rejouer', WIDTH/2 - 140, HEIGHT/2 + 40);
  }

  function updateScore(deltaTime) {
    if(!gameOver) {
      scoreTimer += deltaTime;
      if(scoreTimer >= 60) { // ~1 seconde (60 frames)
        score++;
        scoreTimer = 0;
      }
    }
  }

  function gameLoop(timestamp=0) {
    if(!lastTimestamp) lastTimestamp = timestamp;
    const delta = timestamp - lastTimestamp;
    lastTimestamp = timestamp;

    if(gameRunning) {
      updatePlayer();
      updateZone();
      checkCollision();
      updateScore(delta);

      ctx.clearRect(0,0,WIDTH,HEIGHT);
      drawPlayer();
      drawZone();
      drawScore();

      if(gameOver) {
        drawGameOver();
      }
    }
    requestAnimationFrame(gameLoop);
  }

  // Controls
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key] = true;
    if(!gameRunning) return;
    if(gameOver && e.key === 'Enter') {
      resetGame();
    }
  });
  window.addEventListener('keyup', e => {
    keys[e.key] = false;
  });

  function handleInput() {
    if(!gameRunning || gameOver) {
      player.dx = 0;
      player.dy = 0;
      return;
    }
    player.dx = 0;
    player.dy = 0;
    if(keys['ArrowLeft']) player.dx = -player.speed;
    if(keys['ArrowRight']) player.dx = player.speed;
    if(keys['ArrowUp']) player.dy = -player.speed;
    if(keys['ArrowDown']) player.dy = player.speed;
  }

  // Partie principale
  let lastTimestamp = 0;

  function startGame() {
    startScreen.style.display = 'none';
    canvas.style.display = 'block';
    resetGame();
    gameRunning = true;
  }

  startButton.addEventListener('click', () => {
    startGame();
  });

  // Boucle d'input séparée
  function inputLoop() {
    handleInput();
    if(gameRunning) requestAnimationFrame(inputLoop);
  }

  inputLoop();
  gameLoop();
})();
</script>

</body>
</html>
